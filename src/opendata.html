<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sankey Diagram - Open Food Facts</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-array@1"></script>
    <script src="https://unpkg.com/d3-collection@1"></script>
    <script src="https://unpkg.com/d3-path@1"></script>
    <script src="https://unpkg.com/d3-shape@1"></script>
    <script src="https://unpkg.com/d3-sankey@0"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      #sankey-container {
        width: 100%;
        height: 100%;
        margin: 0 auto;
      }
      svg {
        border: 1px solid #ccc;
      }
      .node rect {
        fill: #3182bd;
        stroke: #000;
      }
      .link {
        fill: none;
        stroke-opacity: 0.7;
      }
      .node text {
        display: none;
      }
      .node:hover text {
        display: block;
      }
    </style>
  </head>
  <body>
    <h1>Sankey Diagram - Open Food Facts</h1>
    <div id="sankey-container"></div>
    <script
      src="data/countries_to_regions_table.js"
      type="text/javascript"
    ></script>
    <script
      src="data/countries_to_subregions_table.js"
      type="text/javascript"
    ></script>
    <script
      src="data/subregions_to_regions_table.js"
      type="text/javascript"
    ></script>
    <script
      src="data/subregions_to_countries_table.js"
      type="text/javascript"
    ></script>
    <script
      src="data/regions_to_countries_table.js"
      type="text/javascript"
    ></script>
    <script
      src="data/regions_to_subregions_table.js"
      type="text/javascript"
    ></script>
    <script src="data/clean_data.js" type="text/javascript"></script>
    <script>
      // Set up the SVG container
      const width = 1600;
      const height = 600;
      const svg = d3
        .select("#sankey-container")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      // Create Sankey generator
      const sankey = d3
        .sankey()
        .nodeWidth(20)
        .nodePadding(15)
        .size([width - 41, height - 41]);

      let nodeIndex = 0;
      const nodes = [];
      const nodeIndexMap = new Map();

      function nodeUniqueName(name, type) {
        return `${type}:${name}`;
      }

      // Helper function to add nodes and create a unique index for each
      function addNode(name, type) {
        // get unique name
        const uniqueName = nodeUniqueName(name, type);

        // return the node if it already exist
        if (nodeIndexMap.has(uniqueName)) {
          return;
        }

        // create a node if it do not exist
        nodes.push({ name: uniqueName, zone: name, type: type, value: 1 });
        nodeIndexMap.set(uniqueName, nodeIndex);
        nodeIndex += 1;
        //console.log(`Adding node : ${uniqueName}`);
        return;
      }

      let linkIndex = 0;
      const links = [];
      const linkIndexMap = new Map();

      function linkUniqueName(node1UniqueName, node2UniqueName) {
        return `${node1UniqueName} -> ${node2UniqueName}`;
      }

      function addLink(name1, type1, name2, type2) {
        // get unique name
        const node1UniqueName = nodeUniqueName(name1, type1);
        const node2UniqueName = nodeUniqueName(name2, type2);
        const uniqueName = linkUniqueName(node1UniqueName, node2UniqueName);

        // increase the value of the link if it already exist
        if (linkIndexMap.has(uniqueName)) {
          links[linkIndexMap.get(uniqueName)].value += 1;
          return;
        }

        // create a link if it do not exist
        links.push({
          source: nodeIndexMap.get(node1UniqueName),
          target: nodeIndexMap.get(node2UniqueName),
          type: type2,
          value: 1,
        });
        linkIndexMap.set(uniqueName, linkIndex);
        linkIndex += 1;
        //console.log(`Adding link : ${uniqueName}`);
        return;
      }

      const PRODUCT_TYPE = "product";
      const ORIGIN_TYPE = "origin";
      const MANUFACTURING_PLACE_TYPE = "manu";
      const SELLING_PALCE_TYPE = "selling";
      const CATEGORIE_TYPE = "categorie";

      const WORLD_ZOOM = 0;
      const REGION_ZOOM = 1;
      const SUBREGION_ZOOM = 2;
      const COUNTRY_ZOOM = 3;

      const ALLCATEGORIE_ZOOM = 0;
      const CATEGORIE_ZOOM = 1;
      const SUBCATEGORIE_ZOOM = 2;

      function map_zoom_to_groups(type, zoom, name) {
        switch (type) {
          case ORIGIN_TYPE:
          case MANUFACTURING_PLACE_TYPE:
          case SELLING_PALCE_TYPE:
            switch (zoom) {
              case WORLD_ZOOM: return Object.keys(regions_to_countries); // world's regions
              case REGION_ZOOM: return regions_to_subregions[name];      // region's subregions
              case SUBREGION_ZOOM: return subregions_to_countries[name]; // subregion's counties
              case COUNTRY_ZOOM: return [name];                          // just a country
            };
            break;

          case CATEGORIE_TYPE:
            switch (zoom) {
              case ALLCATEGORIE_ZOOM: return [];// need to be set to categorie dict keys list
              case CATEGORIE_ZOOM: return [];   // need to be set to categorie dict entry
              case SUBCATEGORIE_ZOOM: return [];// need to be set to subcategorie dict entry
            };
            break;
        }
        console.log("invalid map : t:", type, " - z:", zoom, " - n:", name);
        return [];
      };

      function get_highzoom_to_zoom_dict(type, zoom) {
        switch (type) {
          case ORIGIN_TYPE:
          case MANUFACTURING_PLACE_TYPE:
          case SELLING_PALCE_TYPE:
            switch (zoom) {
              case WORLD_ZOOM: return ((c) => countries_to_regions[c]);
              case REGION_ZOOM: return ((c) => countries_to_subregions[c]);
              case SUBREGION_ZOOM: return ((c) => c);
              case COUNTRY_ZOOM: return ((c) => c);
            };
            break;

          case CATEGORIE_TYPE:
            switch (zoom) {
              case ALLCATEGORIE_ZOOM: return ((c) => c);// need to be set to categorie dict keys list
              case CATEGORIE_ZOOM: return ((c) => c);   // need to be set to categorie dict entry
              case SUBCATEGORIE_ZOOM: return ((c) => c);// need to be set to subcategorie dict entry
            };
            break;
        }
        console.log("invalid map : t:", type, " - z:", zoom);
        return false;
      }
      // The current state of the schema
      let currentState = {
        product_state: { zoom: CATEGORIE_ZOOM },
        origin_state: { zoom: WORLD_ZOOM },
        manu_state: { zoom: WORLD_ZOOM },
        selling_state: { zoom: WORLD_ZOOM },
      };

      function data_to_graph_filtered(
        { originZoom, nameOrigin },
        { manuZoom, nameManu },
        { sellingZoom, nameSelling },
        { categorieZoom, nameCategorie },
      ) {
        nodes.length = 0;
        links.length = 0;

        // get groups of allowed elts
        filtered_origin_groups = map_zoom_to_groups(ORIGIN_TYPE, originZoom, nameOrigin);
        filtered_manu_groups = map_zoom_to_groups(MANUFACTURING_PLACE_TYPE, manuZoom, nameManu);
        filtered_selling_groups = map_zoom_to_groups(SELLING_PALCE_TYPE, sellingZoom, nameSelling);
        filtered_cat_groups = map_zoom_to_groups(CATEGORIE_TYPE, categorieZoom, nameCategorie);

        // adding Nodes
        filtered_origin_groups.forEach((zone) => {
          addNode(zone, ORIGIN_TYPE);
        }); 

        filtered_manu_groups.forEach((zone) => {
          addNode(zone, MANUFACTURING_PLACE_TYPE);
        });

        filtered_selling_groups.forEach((zone) => {
          addNode(zone, SELLING_PALCE_TYPE);
        });

        filtered_cat_groups.forEach((zone) => {
          addNode(zone, CATEGORIE_TYPE);
        });

        origin_dict = get_highzoom_to_zoom_dict(ORIGIN_TYPE, originZoom);
        manu_dict = get_highzoom_to_zoom_dict(MANUFACTURING_PLACE_TYPE, manuZoom);
        selling_dict = get_highzoom_to_zoom_dict(SELLING_PALCE_TYPE, sellingZoom);
        cat_duct = get_highzoom_to_zoom_dict(CATEGORIE_TYPE, categorieZoom);

        products.map((product) => {
          if (!product.product_name) return;
          if (!product.origins_tags_std) return;
          if (!product.manufacturing_places_tags_std) return;
          if (!product.countries_tags_std) return;
          
          
          oml = []
          product.origins_tags_std.forEach((origin) =>{ 
            product.manufacturing_places_tags_std.forEach((manu) =>{
              o = origin_dict(origin);
              m = manu_dict(manu);
              if (filtered_origin_groups.includes(o) && filtered_manu_groups.includes(m)) {
                oml.push({o:o, ot:ORIGIN_TYPE, m:m, mt:MANUFACTURING_PLACE_TYPE});
              }
            });
          });

          mcl = []
          product.manufacturing_places_tags_std.forEach((manu) =>{
            product.countries_tags_std.forEach((sell) =>{
              m = manu_dict(manu);
              s = selling_dict(sell);
              if (filtered_manu_groups.includes(m) && filtered_selling_groups.includes(s)) {
                mcl.push({m:m, mt:MANUFACTURING_PLACE_TYPE, c:s, ct:SELLING_PALCE_TYPE});
              }
            });
          });

          if(oml.length>0 && mcl.length>0) {
            oml.forEach(({o,ot, m, mt}) => {
              addLink(o, ot, m, mt);
            });
            mcl.forEach(({m, mt, c, ct}) => {
              addLink(m, mt, c, ct);
            });
          }
          //product.origins_tags_std.forEach((origin) => {
          //  addLink(product.product_name, PRODUCT_TYPE, origin, ORIGIN_TYPE);
          //});

        });
      }

      data_to_graph_filtered(
        { originZoom: WORLD_ZOOM, nameOrigin: "" },
        { manuZoom: WORLD_ZOOM, nameManu: "" },
        { sellingZoom: WORLD_ZOOM, nameSelling: "" },
        { categorieZoom: ALLCATEGORIE_ZOOM, nameCategorie: "" },
      );

      function zoomIn(d) {
        // Left click
        console.log("Left clicked on: ", d.name);
        if (d.type == ORIGIN_TYPE) {
          const current_origin_state = currentState.origin_state.zoom;
          if (current_origin_state == WORLD_ZOOM) {
            currentState.origin_state.zoom = REGION_ZOOM;
          } else if (current_origin_state == REGION_ZOOM) {
            currentState.origin_state.zoom = SUBREGION_ZOOM;
          } else if (current_origin_state == SUBREGION_ZOOM) {
            currentState.origin_state.zoom = COUNTRY_ZOOM;
          } else {
            currentState.origin_state.zoom = WORLD_ZOOM;
          }
        } else if (d.type == MANUFACTURING_PLACE_TYPE) {
          const current_manu_state = currentState.manu_state.zoom;
          if (current_manu_state == WORLD_ZOOM) {
            currentState.manu_state.zoom = REGION_ZOOM;
          } else if (current_manu_state == REGION_ZOOM) {
            currentState.manu_state.zoom = SUBREGION_ZOOM;
          } else if (current_manu_state == SUBREGION_ZOOM) {
            currentState.manu_state.zoom = COUNTRY_ZOOM;
          } else {
            currentState.manu_state.zoom = WORLD_ZOOM;
          }
        } else if (d.type == SELLING_PALCE_TYPE) {
          const current_selling_state = currentState.selling_state.zoom;
          if (current_selling_state == WORLD_ZOOM) {
            currentState.selling_state.zoom = REGION_ZOOM;
          } else if (current_selling_state == REGION_ZOOM) {
            currentState.selling_state.zoom = SUBREGION_ZOOM;
          } else if (current_selling_state == SUBREGION_ZOOM) {
            currentState.selling_state.zoom = COUNTRY_ZOOM;
          } else {
            currentState.selling_state.zoom = WORLD_ZOOM;
          }
        } else if (d.type == PRODUCT_TYPE) {
          const current_product_state = currentState.product_state.zoom;
          if (current_product_state == ALLCATEGORIE_ZOOM) {
            currentState.product_state.zoom = CATEGORIE_ZOOM;
          } else if (current_product_state == CATEGORIE_ZOOM) {
            currentState.product_state.zoom = SUBCATEGORIE_ZOOM;
          } else {
            currentState.product_state.zoom = ALLCATEGORIE_ZOOM;
          }
        }
        // Add your left click callback logic here
        data_to_graph_filtered(
          {
            originZoom: currentState.origin_state.zoom,
            nameOrigin: d.name.split(":")[1],
          },
          {
            manuZoom: currentState.manu_state.zoom,
            nameManu: d.name.split(":")[1],
          },
          {
            sellingZoom: currentState.selling_state.zoom,
            nameSelling: d.name.split(":")[1],
          },
          {
            categorieZoom: currentState.product_state.zoom,
            nameCategorie: d.name.split(":")[1],
          },
        );

        drawGraph();
      }

      function zoomOut(d) {
        console.log("Right clicked on: ", d.name);

        // dezoom
        if (d.type == ORIGIN_TYPE) {
          const current_origin_state = currentState.origin_state.zoom;
          if (current_origin_state == WORLD_ZOOM) {
            currentState.origin_state.zoom = COUNTRY_ZOOM;
          } else if (current_origin_state == REGION_ZOOM) {
            currentState.origin_state.zoom = WORLD_ZOOM;
          } else if (current_origin_state == SUBREGION_ZOOM) {
            currentState.origin_state.zoom = REGION_ZOOM;
          } else {
            currentState.origin_state.zoom = SUBREGION_ZOOM;
          }
        } else if (d.type == MANUFACTURING_PLACE_TYPE) {
          const current_manu_state = currentState.manu_state.zoom;
          if (current_manu_state == WORLD_ZOOM) {
            currentState.manu_state.zoom = COUNTRY_ZOOM;
          } else if (current_manu_state == REGION_ZOOM) {
            currentState.manu_state.zoom = WORLD_ZOOM;
          } else if (current_manu_state == SUBREGION_ZOOM) {
            currentState.manu_state.zoom = REGION_ZOOM;
          } else {
            currentState.manu_state.zoom = SUBREGION_ZOOM;
          }
        } else if (d.type == SELLING_PALCE_TYPE) {
          const current_selling_state = currentState.selling_state.zoom;
          if (current_selling_state == WORLD_ZOOM) {
            currentState.selling_state.zoom = COUNTRY_ZOOM;
          } else if (current_selling_state == REGION_ZOOM) {
            currentState.selling_state.zoom = WORLD_ZOOM;
          } else if (current_selling_state == SUBREGION_ZOOM) {
            currentState.selling_state.zoom = REGION_ZOOM;
          } else {
            currentState.selling_state.zoom = SUBREGION_ZOOM;
          }
        } else if (d.type == PRODUCT_TYPE) {
          const current_product_state = currentState.product_state.zoom;
          if (current_product_state == ALLCATEGORIE_ZOOM) {
            currentState.product_state.zoom = SUBCATEGORIE_ZOOM;
          } else if (current_product_state == CATEGORIE_ZOOM) {
            currentState.product_state.zoom = ALLCATEGORIE_ZOOM;
          } else {
            currentState.product_state.zoom = CATEGORIE_ZOOM;
          }
        }

        data_to_graph_filtered(
          {
            originZoom: currentState.origin_state.zoom,
            nameOrigin: d.name.split(":")[1],
          },
          {
            manuZoom: currentState.manu_state.zoom,
            nameManu: d.name.split(":")[1],
          },
          {
            sellingZoom: currentState.selling_state.zoom,
            nameSelling: d.name.split(":")[1],
          },
          {
            categorieZoom: currentState.product_state.zoom,
            nameCategorie: d.name.split(":")[1],
          },
        );

        drawGraph();
      }

      // function to draw the graph
      // will update the graph with the new data
      function drawGraph() {
        // Generate the Sankey diagram
        const { nodes: sankeyNodes, links: sankeyLinks } = sankey({
          nodes: nodes.map((d) => Object.assign({}, d)),
          links: links.map((d) => Object.assign({}, d)),
        });

        // Set node positions based on type to separate columns
        sankeyNodes.forEach((node) => {
          if (node.type === PRODUCT_TYPE) {
            node.x0 = 0;
            node.x1 = sankey.nodeWidth();
          } else if (node.type === ORIGIN_TYPE) {
            node.x0 = width / 4;
            node.x1 = width / 4 + sankey.nodeWidth();
          } else if (node.type === MANUFACTURING_PLACE_TYPE) {
            node.x0 = (2 * width) / 4;
            node.x1 = (2 * width) / 4 + sankey.nodeWidth();
          } else if (node.type === SELLING_PALCE_TYPE) {
            node.x0 = (3 * width) / 4;
            node.x1 = (3 * width) / 4 + sankey.nodeWidth();
          }
        });

        // Draw links
        svg
          .append("g")
          .selectAll("path")
          .data(sankeyLinks)
          .join("path")
          .attr("class", "link")
          .attr("d", d3.sankeyLinkHorizontal())
          .attr("stroke-width", (d) => d.width)
          .attr("stroke", (d) => {
            if (d.type === ORIGIN_TYPE) {
              return "#ff7f0e";
            } else if (d.type === MANUFACTURING_PLACE_TYPE) {
              return "#2ca02c";
            } else if (d.type === SELLING_PALCE_TYPE) {
              return "#1f77b4";
            } else {
              return "#6baed6";
            }
          });

        // Draw nodes
        const node = svg
          .append("g")
          .selectAll("g")
          .data(sankeyNodes)
          .join("g")
          .attr("class", "node")
          .on("click", (event, d) => {
            if (event.button === 0) {
              zoomIn(d);
            }
          })
          .on("contextmenu", (event, d) => {
            event.preventDefault();
            zoomOut(d);
          });

        node
          .append("rect")
          .attr("x", (d) => d.x0)
          .attr("y", (d) => d.y0)
          .attr("height", (d) => Math.max(1, d.y1 - d.y0))
          .attr("width", (d) => 20)
          .attr("stroke", (d) => {
            if (d.type === ORIGIN_TYPE) {
              return "#ff7f0e";
            } else if (d.type === MANUFACTURING_PLACE_TYPE) {
              return "#2ca02c";
            } else if (d.type === SELLING_PALCE_TYPE) {
              return "#1f77b4";
            } else {
              return "#6baed6";
            }
          });

        // Add labels (hidden by default, shown on hover)
        node
          .append("text")
          .attr("x", (d) => d.x0 - 6)
          .attr("y", (d) => (d.y1 + d.y0) / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "end")
          .text((d) => d.name)
          .filter((d) => d.x0 < width / 2)
          .attr("x", (d) => d.x1 + 6)
          .attr("text-anchor", "start");
      }

      drawGraph();
    </script>
  </body>
</html>
